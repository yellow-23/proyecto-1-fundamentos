# -*- coding: utf-8 -*-
"""BUSQUEDA NO INFORMADA (jarros de agua).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oU-sc5ZrwEw_lbJNc9mWn1yE_bHghQ-V
"""

from  heapq import heappush, heappop

class nodo:
    def __init__(self, j1, j2, padre, costo):
        self.J1 = j1
        self.J2 = j2
        self.padre = padre
        self.costo = costo

    def __lt__(self, otroNodo):
        return self.costo < otroNodo.costo

    def __str__(self):
        return "(" + str(self.J1) + "," + str(self.J2) + ") costo: " + str(self.costo)

    def __eq__(self,otroNodo):
        return self.J1 == otroNodo.J1 and self.J2 == otroNodo.J2

    def aplicaRegla(self, regla):

        if regla == 1 and self.J1 < 4:              # Llenar J1 (debe tener espacio)
            return nodo(4, self.J2, self, self.costo+1)

        elif regla == 2 and self.J2 < 3:            # Llenar J2 (debe tener espacio)
            return nodo(self.J1, 3, self, self.costo+1)

        elif regla == 3 and self.J1 > 0 and self.J2 < 3: # J1 -> J2 (J1 debe tener agua y J2 debe tener espacio)
            falta = 3 - self.J2
            if self.J1 < falta: # Si J1 tiene menos de lo que le falta a J2:
                return nodo(0, self.J2 + self.J1, self, self.costo+1)    ## Se agrega a J2 lo que posee J1
            else:
                return nodo(self.J1-falta, self.J2+falta, self, self.costo+1) ## Se agrega a J2 lo que le falta y se le quita a J1

        elif regla == 4 and self.J1 < 4 and self.J2 > 0:    # J2 -> J1 (J1 debe tener espacio y J2 debe tener agua)
            falta = 4 - self.J1
            if self.J2 < falta:
                return nodo(self.J1 + self.J2, 0, self, self.costo+1)    ## Se agrega a J1 lo que posee J2
            else:
                return nodo(self.J1+falta, self.J2-falta, self, self.costo+1)    ## Se agrega a J1 lo que le falta y se le quita a J2

        elif regla == 5 and self.J1 > 0:
            return nodo(0, self.J2, self, self.costo+1)

        elif regla == 6 and self.J2 > 0:
            return nodo(self.J1, 0, self, self.costo+1)

        return None     #No se pudo aplicar ninguna regla

    def sucesores(self, ABIERTOS, CERRADOS):
        listaSucesores = []
        for i in range(1,7):
            sucesor = self.aplicaRegla(i)
            if sucesor is not None and sucesor not in ABIERTOS and sucesor not in CERRADOS:
                listaSucesores.append(sucesor)
        return listaSucesores

    def esMeta(self):
        if self.J1 == 2 and self.J2 == 0 or self.J1 == 0 and self.J2 == 2:
            return True
        else:
            return False

# ------------fin clase nodo ------------------------

def ingresaLista(lista, nodo, esquema):
    if esquema == "BFS":
        lista.append(nodo)    #BFS: Ingreso al final
    if esquema == "DFS":
        lista.insert(0, nodo)    #DFS: Ingreso al inicio
    if esquema == "UCS":
        heappush(lista, nodo)
    return lista

def Solucion(nodo, inicial):
    solucion = []
    while nodo is not inicial:
        solucion = [str(nodo)] + solucion
        nodo = nodo.padre
    return [str(inicial)] + solucion

def busquedaNoInformada(nodoInicial, esquema):
    ABIERTOS = [nodoInicial]
    CERRADOS = []
    exito = False
    fracaso = False
    while not exito and not fracaso:
        if esquema == "UCS":
            nodoActual = heappop(ABIERTOS)
        else:
            nodoActual = ABIERTOS.pop(0)
        CERRADOS.append(nodoActual)
        if nodoActual.esMeta():
            exito = True
        else:
            listaSucesores = nodoActual.sucesores(ABIERTOS, CERRADOS)
            for nodo in listaSucesores:
                ABIERTOS = ingresaLista(ABIERTOS, nodo, esquema)
            if ABIERTOS == []:
                fracaso = True
    if exito:
        return Solucion(nodoActual, inicial), len(CERRADOS)
    else:
        return None

#---- BLOQUE PRINCIPAL:
# Cambiar el esquema por "BFS", "DFS", "UCS"
inicial = nodo(0, 0, None, 0)
esquema = "UCS"
respuesta, nodosRevisados = busquedaNoInformada(inicial, esquema)
if respuesta is None:
    print("No se encontró solución")
else:
    print(f"Cantidad de nodos revisados: {nodosRevisados} nodos")
    print(f"\nSolución encontrada por {esquema}: ")
    for nodo in respuesta:
        print(nodo)

