# -*- coding: utf-8 -*-
"""Aestrella (puzzle-8).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AprBec9CrZKVUbJqVibY6YLkTxCgtkXX
"""

from numpy import array, zeros, copy, array_equal, where
from  heapq import heappush, heappop

class nodo:
    def __init__(self, puzzle, pos0, padre, costo):
        self.puzzle = copy(puzzle)
        self.pos0 = pos0
        self.padre = padre
        self.costo = costo
        self.f = self.costo + self.heuristica2()

    def __lt__(self, otroNodo):
        return self.f < otroNodo.f

    def __str__(self):
        return '\n'.join(' '.join(str(x) for x in fila) for fila in self.puzzle) #formatea la matriz para que salga sin corchetes.

    def __eq__(self,otroNodo):
        return array_equal(self.puzzle, otroNodo.puzzle)

    def heuristica1(self):  #Número de piezas fuera de su posición

        meta = array([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
        fueraDePos = (self.puzzle != meta) & (self.puzzle != 0)
        return fueraDePos.sum()

    def heuristica2(self):  #Distancia de cada pieza a su lugar en la meta (se llama "Distancia de Manhattan")

        meta = array([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
        distancia = 0
        for numero in range(1, 9):
            f, c = where(self.puzzle == numero)
            fmeta, cmeta = where(meta == numero)
            distancia += abs(f[0] - fmeta[0]) + abs(c[0] - cmeta[0])
        return distancia

    def aplicaRegla(self, regla):
        puzzle = copy(self.puzzle)
        fila0, col0 = self.pos0

        if regla == 1 and fila0 > 0:  # intercambia el espacio con celda de arriba
            puzzle[fila0, col0] = puzzle[fila0-1, col0]
            puzzle[fila0-1, col0] = 0
            return nodo(puzzle, (fila0-1,col0), self, self.costo + 1)

        elif regla == 2 and col0 < 2: # intercambia el espacio con celda de la derecha
            puzzle[fila0, col0] = puzzle[fila0, col0+1]
            puzzle[fila0, col0+1] = 0
            return nodo(puzzle, (fila0, col0+1), self, self.costo + 1)

        elif regla == 3 and fila0 < 2:   # intercambia el espacio con celda de abajo
            puzzle[fila0, col0] = puzzle[fila0+1, col0]
            puzzle[fila0+1, col0] = 0
            return nodo(puzzle, (fila0+1, col0), self, self.costo + 1)

        elif regla == 4 and col0 > 0:    # intercambia el espacio con celda de la izquierda
            puzzle[fila0, col0] = puzzle[fila0, col0-1]
            puzzle[fila0, col0-1] = 0
            return nodo(puzzle, (fila0, col0-1), self, self.costo + 1)
        return None

    def esMeta(self):
        meta = array([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
        return array_equal(self.puzzle, meta)

    def sucesores(self, ABIERTOS, CERRADOS):
        listaSucesores = []
        for i in range(1,5):
            sucesor = self.aplicaRegla(i)
            if sucesor is not None and sucesor not in ABIERTOS and sucesor not in CERRADOS:

                listaSucesores.append(sucesor)
        return listaSucesores

# ------------fin clase nodo ------------------------

def ingresaLista(lista, nodo):
    heappush(lista, nodo)
    return lista

def Solucion(nodo, inicial):
    solucion = []
    while nodo is not inicial:
        solucion = [str(nodo)] + solucion
        nodo = nodo.padre
    return [str(inicial)] + solucion

def Aestrella(nodoInicial):

    ABIERTOS = []
    heappush(ABIERTOS, nodoInicial)
    CERRADOS = []
    éxito = False
    fracaso = False
    cont = 0
    while not éxito and not fracaso and cont <= MAX:

        nodoActual = heappop(ABIERTOS)
        CERRADOS.append(nodoActual)

        if nodoActual.esMeta():
            éxito = True
        else:
            listaSucesores = nodoActual.sucesores(ABIERTOS, CERRADOS)
            for nodo in listaSucesores:
                heappush(ABIERTOS, nodo)
            if ABIERTOS == []:
                fracaso = True
        cont += 1
    if éxito:
        return Solucion(nodoActual, nodoInicial), cont
    else:
        return None, cont

#---- BLOQUE PRINCIPAL:

inicial = nodo(array([[4, 7, 3],[2, 0, 5],[8, 1, 6]]), (1,1), None, 0)

MAX = 3000

respuesta, nodosRevisados = Aestrella(inicial)
if respuesta is None:
    print(f"Cantidad de nodos revisados: {nodosRevisados} nodos")
    print("No se encontró solución")
else:
    print(f"Cantidad de nodos revisados: {nodosRevisados} nodos")
    for nodo in respuesta:
        print(f"\n{nodo}")